
public class minHeap {

	public int[] array;
	public int size;

	public minHeap(int size) {
		array = new int[size];

	}

	public void insert(int item) {

	}

	public void buildMaxHeap()
	{
		
	}

	private void heapify(int seat) {
		int temp;
		int leftChildIndex = leftChild(seat);
		int rightChildIndex = rightChild(seat);

		if (!isLeaf(seat)) {
			
			if (array[leftChildIndex] < array[seat]) // Left child is the smallest
			{
				temp = array[leftChildIndex];
				array[leftChildIndex] = array[seat];
				array[seat] = temp;
				heapify(leftChildIndex);
			}

			if (array[rightChildIndex] < array[seat]) // Right child is the smallest
			{
				temp = array[rightChildIndex];
				array[rightChildIndex] = array[seat];
				array[seat] = temp;
				heapify(rightChildIndex);
			}
		}

	}

	private boolean isLeaf(int seat) {
		if (leftChild(seat) == -1) // The left child doesn't exist
			return true;
		else
			return false;
	}

	/*
	 * Return the seat of parent node. Returns -1 if the parent does not exist.
	 */
	private int parent(int seat) {
		int parentSeat = (int) Math.floor(seat / 2);
		if (parentSeat < 1)
			return -1; // There is no parent!
		else
			return parentSeat;
	}

	/*
	 * Return the seat of left child node. Returns -1 if the left child does not
	 * exist.
	 */
	private int leftChild(int seat) {
		int LChildSeat = (seat * 2);
		if (LChildSeat > size)
			return -1; // There is no leftChild
		else
			return LChildSeat;
	}

	/*
	 * Return the seat of right child node. Returns -1 if the right child does
	 * not exist.
	 */
	private int rightChild(int seat) {
		int RChildSeat = (seat * 2 + 1);
		if (RChildSeat > size)
			return -1; // There is no leftChild
		else
			return RChildSeat;
	}

}
