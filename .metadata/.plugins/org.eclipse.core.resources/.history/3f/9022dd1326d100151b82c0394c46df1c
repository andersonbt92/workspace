
public class MinHeap {

	private int[] heap;
	private int size; //number of items in the heap

	public MinHeap(int[] array) 
	{
		heap = new int[(array.length + 1)];

		for(int i=0;i<array.length;i++)
		{
			heap[(i+1)] = array[i];
		}
		size = heap.length-1;
		buildMinHeap();
	}

	public int getSize()
	{
		return size;
	}

	public void buildMinHeap()
	{
		for(int index = (int) Math.floor(size/2); index>=1; index--)
		{
			heapify(index);
		}
	}

	public int[] returnHeapAsSortedArray()
	{
		int[] returnArray = new int[size];
		for(int i=0;i<returnArray.length;i++)
		{
			returnArray[i]= removeRoot();
		}

		return returnArray;
	}

	public void replaceRoot(int value)
	{
		heap[1]=value;
		heapify(1);
	}

	public int removeRoot()
	{
		int root = heap[1];
		size--;
		int[] newArray = new int[(size+1)];
		for(int i = 1; i<newArray.length;i++)
		{
			newArray[i]= heap[i+1];
		}
		heap=newArray;
		heapify(1);
		return root;
	}

	public int getRoot()
	{
		return heap[1];
	}

	private void heapify(int seat) {
		int temp;
		int leftChildIndex = leftChild(seat);
		int rightChildIndex = rightChild(seat);

		if (!(isLeaf(seat))) {

			if(rightChildIndex == -1)//There is no right child
			{
				if(heap[leftChildIndex]< heap[seat]) //if the left child is smaller
				{
					temp = heap[leftChildIndex];
					heap[leftChildIndex] = heap[seat];
					heap[seat] = temp;
					heapify(leftChildIndex);
				}
			} //We know if there is no left child then the seat is a leaf

			if(heap[leftChildIndex]< heap[seat]|| heap[rightChildIndex]< heap[seat]) //If either of the children are smaller
			{
				if(heap[leftChildIndex] < heap[rightChildIndex]) // Left child is the smallest
				{
					temp = heap[leftChildIndex];
					heap[leftChildIndex] = heap[seat];
					heap[seat] = temp;
					heapify(leftChildIndex);
				}

				if (heap[rightChildIndex] < heap[leftChildIndex]) // Right child is the smallest
				{
					temp = heap[rightChildIndex];
					heap[rightChildIndex] = heap[seat];
					heap[seat] = temp;
					heapify(rightChildIndex);
				}
			}
		}
	}

	private boolean isLeaf(int seat) {
		if (leftChild(seat) == -1) // The left child doesn't exist
			return true;
		else
			return false;
	}

	/*
	 * Return the seat of parent node. Returns -1 if the parent does not exist.
	 *
	private int parent(int seat) {
		int parentSeat = (int) Math.floor(seat / 2);
		if (parentSeat < 1)
			return -1; // There is no parent!
		else
			return parentSeat;
	}

	/*
	 * Return the seat of left child node. Returns -1 if the left child does not
	 * exist.
	 */
	private int leftChild(int seat) {
		int LChildSeat = (seat * 2);
		if (LChildSeat > size)
			return -1; // There is no leftChild
		else
			return LChildSeat;
	}

	/*
	 * Return the seat of right child node. Returns -1 if the right child does
	 * not exist.
	 */
	private int rightChild(int seat) {
		int RChildSeat = ((seat * 2) + 1);
		if (RChildSeat > size)
			return -1; // There is no rightChild
		else
			return RChildSeat;
	}

}
